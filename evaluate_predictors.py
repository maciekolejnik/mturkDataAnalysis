import math

import numpy as np
from functools import reduce
import math
from random import choice
import statistics as stats

# below evaluation functions of various predictors.
# each takes two parameters:
# - history of play - a list of { invested, returned }
# - role of the participant whose actions we wanna predict
# each returns a dict { mse, pmse }

# we introduce a 'prob_pred' object that represents a probabilistic
# prediction. It is in the following format:
# {
#     'vals': [array of possible actions],
#     'probs': [probabilities of these actions in order]
# }
# Besides that, we also have a deterministic prediction which is
# simply a number (double)

EPSILON = 0.3
PHI = 0.1
MAX_ATF = 2
THRESHOLD = 0.25
C = 0.9


# DANG - from the predicting trust game paper
# their idea is that sending proportion is equal
# to trust value. So prediction will be generated
# based on computing that trust value. Prediction
# generated by Dang predictor is deterministic
def evaluate_dang_predictor(history, human_role, user_id):
    def debug(msg):
        return True
        # user_id == '819y7cnwls' and print(msg)

    bot_role = 'investor' if human_role == 'investee' else 'investee'
    debug(f'eval_dang: for user {user_id} whose role was {human_role}')
    init_acc = {
        'alpha': 0,
        'beta': 0,
        'atf': 0,
        'expect_trust': 0,
        'trend_factor': 0,
        'cur_trust': 0,
        'agg_trust': 0,
        'change_rate': 0,
        'trust_value': 0.5,
        'errors': []
    }

    def f(acc, transfers):
        sending_amount = {
            'investor': transfers['invested'],
            'investee': transfers['returned']
        }
        invested = transfers['invested']
        returned = transfers['returned']
        debug(f'eval_dang: process {invested}, {returned} round')
        # this is sending amount of the bot
        # bot_sending_amount = returned if human_role == 'investor' else invested
        # bot_max_sending_amount = 4 if human_role == 'investee' else 2 * invested
        max_sending_amount = {
            'investor': 4,
            'investee': 2 * invested
        }
        compute_send_prop = \
            lambda role: 0 if max_sending_amount[role] == 0 \
                else sending_amount[role] / max_sending_amount[role]
        send_proportion = \
            { role : compute_send_prop(role) for role in sending_amount.keys() }
        # bot_send_proportion = 0 if bot_max_sending_amount == 0 else \
        #     bot_sending_amount / bot_max_sending_amount
        # eq (2) from paper
        cur_trust = math.log(send_proportion[human_role] * (math.e - 1) + 1)
        debug(f'eval_dang: cur_trust={cur_trust}')
        delta = abs(cur_trust - acc['cur_trust'])  # eq (3)
        beta = C * delta + (1 - C) * acc['beta']  # eq (4)
        alpha = THRESHOLD + C * delta / (1 + beta)  # eq (5)
        agg_trust = (alpha * cur_trust +
                     (1 - alpha) * acc['agg_trust'])  # eq (6)
        phi = PHI if cur_trust - agg_trust > EPSILON else \
            -PHI if agg_trust - cur_trust > EPSILON else 0
        trend_factor = acc['trend_factor'] + phi  # eq (7)
        adj_atf = acc['atf'] / 2 if acc['atf'] > MAX_ATF else acc[
            'atf']  # eq (8)
        atf_mod = \
            (cur_trust - agg_trust) / 2 if cur_trust - agg_trust > PHI else \
                agg_trust - cur_trust if agg_trust - cur_trust > PHI else 0
        atf = adj_atf + atf_mod
        change_rate = 0 if atf > MAX_ATF else math.cos(
            math.pi / 2 * atf / MAX_ATF)
        expect_trust = trend_factor * cur_trust + (1 - trend_factor) * agg_trust
        trust_value = expect_trust * change_rate  # eq (11)
        # evaluate prediction; predicted action is a proportion of max
        # transfer equal to trust value
        predicted_human_action = acc['trust_value'] * max_sending_amount[human_role]
        debug(f'eval_dang: predicted action={predicted_human_action}')
        # print(f'round={len(acc["errors"])}: predicted: {predicted_action}, actual: {sending_amount}')
        squared_error = pow(predicted_human_action - sending_amount[human_role], 2)
        return {
            'alpha': alpha,
            'beta': beta,
            'atf': atf,
            'expect_trust': expect_trust,
            'trend_factor': trend_factor,
            'cur_trust': cur_trust,
            'agg_trust': agg_trust,
            'change_rate': change_rate,
            'trust_value': trust_value,
            'errors': acc['errors'] + [squared_error]
        }
    errors = reduce(f, history, init_acc)['errors']
    debug(errors)
    # print(evals)
    mse = stats.mean(errors)
    return {
        'mse': mse
    }


# UNIFORM - always predicts uniform
def evaluate_uniform_predictor(history, role):
    # uniform predictor is evaluated by iterating over history
    def f(acc, transfers):
        human_action = transfers['invested'] if role == 'investor' else \
            transfers['returned']
        possible_actions = [0, 1, 2, 3, 4] if role == 'investor' else \
            list(range(0, 2 * transfers['invested'] + 1))
        prob_pred = get_uniform_prediction(possible_actions)
        det_pred = stats.mean(prob_pred['vals'])
        return {
            'pses': acc['pses'] + [compute_pmse(prob_pred, human_action)],
            'ses': acc['ses'] + [pow(det_pred - human_action, 2)],
        }

    init_acc = {
        'pses': [],
        'ses': [],
    }
    evals = reduce(f, history, init_acc)
    # pmses = list(map(compute_pmse(prediction, action)))
    return {
        'mse': stats.mean(evals['ses']),
        'pmse': stats.mean(evals['pses'])
    }


def get_action_and_range(transfers, role):
    action = transfers['invested'] if role == 'investor' else \
        transfers['returned']
    rng = [0, 1, 2, 3, 4] if role == 'investor' else \
        list(range(0, 2 * transfers['invested'] + 1))
    return action, rng


# LAST - predict next action is same as last (first one uniform)
def evaluate_last_predictor(history, role):
    def f(acc, transfers):
        errors = acc['errors']
        last = acc['last']
        human_action, possible_actions = get_action_and_range(transfers, role)
        prediction = last if last >= 0 else stats.mean(possible_actions)
        squared_error = pow(prediction - human_action, 2)
        return {
            'errors': errors + [squared_error],
            'last': human_action
        }

    init_acc = {
        'errors': [],
        'last': -1
    }
    evals = reduce(f, history, init_acc)
    return {
        'mse': stats.mean(evals['errors'])
    }


# AVERAGE-predict next action is average of previous actions (first one uniform)
def evaluate_avg_predictor(history, role):
    def f(acc, transfers):
        errors = acc['errors']
        avg = acc['average']
        human_action = transfers['invested'] if role == 'investor' else \
            transfers['returned']
        possible_actions = [0, 1, 2, 3, 4] if role == 'investor' else \
            list(range(0, 2 * transfers['invested'] + 1))
        prediction = avg if avg >= 0 else stats.mean(possible_actions)
        squared_error = pow(prediction - human_action, 2)
        updated_avg = (avg * len(errors) + human_action) / (len(errors) + 1)
        return {
            'errors': errors + [squared_error],
            'average': updated_avg
        }

    init_acc = {
        'errors': [],
        'average': -1
    }
    evals = reduce(f, history, init_acc)
    return {
        'mse': stats.mean(evals['errors'])
    }


# RANDOM - predict next action by a random draw
def evaluate_random_predictor(history, role):
    return {
        'mse': 1,
        'pmse': 1
    }


# AUXILIARY STUFF

# pmse is computed
def compute_pmse(prob_pred, action):
    vals = prob_pred.get('vals')
    errors = [pow(action - val, 2) for val in vals]
    probs = prob_pred.get('probs')
    pmse = sum(np.multiply(probs, errors))
    return pmse


def compute_mse(prob_pred, action):
    vals = prob_pred['vals']
    probs = prob_pred['probs']
    biggest_prob = max(probs)
    indexes = [ind for ind, prob in enumerate(probs) if
               math.isclose(prob, biggest_prob)]
    index = choice(indexes)
    val = vals[index]
    return pow(action - val, 2)


def compute_fmse(prob_pred, action):
    vals = prob_pred['vals']
    probs = prob_pred['probs']
    expectation = sum(np.multiply(vals, probs))
    return pow(expectation - action, 2)


# various useful predictions
def get_uniform_prediction(vals):
    prob = 1 / len(vals)
    return {
        'vals': vals,
        'probs': np.repeat(prob, len(vals))
    }
