import math

import numpy as np
from functools import reduce
import math
from random import choice
import statistics as stats

# below evaluation functions of various predictors.
# each takes two parameters:
# - history of play - a list of { invested, returned }
# - role of the participant whose actions we wanna predict
# each returns a dict { mse, pmse }

# we introduce a 'prob_pred' object that represents a probabilistic
# prediction. It is in the following format:
# {
#     'vals': [array of possible actions],
#     'probs': [probabilities of these actions in order]
# }
# Besides that, we also have a deterministic prediction which is
# simply a number (double)

EPSILON = 0.3
PHI = 0.1
MAX_ATF = 2
THRESHOLD = 0.25
C = 0.9


# DANG - from the predicting trust game paper
# their idea is that sending proportion is equal
# to trust value. So prediction will be generated
# based on computing that trust value. Prediction
# generated by Dang predictor is deterministic
def evaluate_dang_predictor(history, role):
    init_acc = {
        'alpha': 0,
        'beta': 0,
        'atf': 0,
        'expect_trust': 0,
        'trend_factor': 0,
        'cur_trust': 0,
        'agg_trust': 0,
        'change_rate': 0,
        'trust_value': 0.5,
        'evals': []
    }

    def f(acc, transfers):
        invested = transfers['invested']
        returned = transfers['returned']
        sending_amount = invested if role == 'investor' else returned
        max_sending_amount = 4 if role == 'investor' else 2 * invested
        send_proportion = 0 if max_sending_amount == 0 else \
            sending_amount / max_sending_amount
        # eq (2) from paper
        cur_trust = math.log(send_proportion * (math.e - 1) + 1)
        delta = abs(cur_trust - acc['cur_trust'])  # eq (3)
        beta = C * delta + (1 - C) * acc['beta']  # eq (4)
        alpha = THRESHOLD + C * delta / (1 + beta)  # eq (5)
        agg_trust = (alpha * cur_trust +
                     (1 - alpha) * acc['agg_trust'])  # eq (6)
        phi = PHI if cur_trust - agg_trust > EPSILON else \
            -PHI if agg_trust - cur_trust > EPSILON else 0
        trend_factor = acc['trend_factor'] + phi  # eq (7)
        adj_atf = acc['atf'] / 2 if acc['atf'] > MAX_ATF else acc[
            'atf']  # eq (8)
        atf_mod = \
            (cur_trust - agg_trust) / 2 if cur_trust - agg_trust > PHI else \
                agg_trust - cur_trust if agg_trust - cur_trust > PHI else 0
        atf = adj_atf + atf_mod
        change_rate = 0 if atf > MAX_ATF else math.cos(
            math.pi / 2 * atf / MAX_ATF)
        expect_trust = trend_factor * cur_trust + (1 - trend_factor) * agg_trust
        trust_value = expect_trust * change_rate  # eq (11)
        # evaluate prediction; predicted action is a proportion of max
        # transfer equal to trust value
        predicted_action = trust_value * max_sending_amount
        pred_eval = pow(predicted_action - sending_amount, 2)
        return {
            'alpha': alpha,
            'beta': beta,
            'atf': atf,
            'expect_trust': expect_trust,
            'trend_factor': trend_factor,
            'cur_trust': cur_trust,
            'agg_trust': agg_trust,
            'change_rate': change_rate,
            'trust_value': trust_value,
            'evals': acc['evals'] + [pred_eval]
        }

    evals = reduce(f, history, init_acc)['evals']
    fse = stats.mean(evals)
    return {
        'mse': fse,
        'pmse': fse,
        'fse': fse
    }


# UNIFORM - always predicts uniform
def evaluate_uniform_predictor(history, role):
    # uniform predictor is evaluated by iterating over history
    def f(acc, transfers):
        human_action = transfers['invested'] if role == 'investor' else \
            transfers['returned']
        possible_actions = [0, 1, 2, 3, 4] if role == 'investor' else \
            list(range(0, 2 * transfers['invested'] + 1))
        pred = get_uniform_prediction(possible_actions)
        # pmse = compute_pmse(pred, human_action)
        return {
            'pmse': acc['pmse'] + [compute_pmse(pred, human_action)],
            'mse': acc['mse'] + [compute_mse(pred, human_action)],
            'fse': acc['fse'] + [compute_fmse(pred, human_action)]
        }

    init_acc = {
        'pmse': [],
        'mse': [],
        'fse': []
    }
    evals = reduce(f, history, init_acc)
    # pmses = list(map(compute_pmse(prediction, action)))
    return {
        'mse': stats.mean(evals['mse']),
        'pmse': stats.mean(evals['pmse']),
        'fse': stats.mean(evals['fse'])
    }


# LAST - predict next action is same as last (first one uniform)
def evaluate_last_predictor(history, role):
    return {
        'mse': 1,
        'pmse': 1
    }


# AVERAGE-predict next action is average of previous actions (first one uniform)
def evaluate_avg_predictor(history, role):
    return {
        'mse': 1,
        'pmse': 1
    }


# RANDOM - predict next action by a random draw
def evaluate_random_predictor(history, role):
    return {
        'mse': 1,
        'pmse': 1
    }


# AUXILIARY STUFF

# pmse is computed
def compute_pmse(prob_pred, action):
    vals = prob_pred.get('vals')
    errors = [pow(action - val, 2) for val in vals]
    probs = prob_pred.get('probs')
    pmse = sum(np.multiply(probs, errors))
    return pmse


def compute_mse(prob_pred, action):
    vals = prob_pred['vals']
    probs = prob_pred['probs']
    biggest_prob = max(probs)
    indexes = [ind for ind, prob in enumerate(probs) if
               math.isclose(prob, biggest_prob)]
    index = choice(indexes)
    val = vals[index]
    return pow(action - val, 2)


def compute_fmse(prob_pred, action):
    vals = prob_pred['vals']
    probs = prob_pred['probs']
    expectation = sum(np.multiply(vals, probs))
    return pow(expectation - action, 2)


# various useful predictions
def get_uniform_prediction(vals):
    prob = 1 / len(vals)
    return {
        'vals': vals,
        'probs': np.repeat(prob, len(vals))
    }
